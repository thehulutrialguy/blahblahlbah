//utility function to return an array of GuiButtons from an array of JS objects, while automatically binding them 
function button_utility_script(inputArr, bindingClass, actionBindMode) {
    // By ZXMushroom63
    // action bind mode:
    // 0 - bind to the same as the binding class
    // 1 - do not bind
    // 2 - bind to GuiScreen
    actionBindMode ||= 0;
    var button = ModAPI.reflect.getClassById("net.minecraft.client.gui.GuiButton").constructors.find(x => x.length === 6);
    var originalActionPerformed = ModAPI.hooks.methods[ModAPI.util.getMethodFromPackage(actionBindMode === 2 ? "net.minecraft.client.gui.GuiScreen" : bindingClass, "actionPerformed")];
    var originalInit = ModAPI.hooks.methods[ModAPI.util.getMethodFromPackage(bindingClass, "initGui")];
    var out = inputArr.flatMap(x => {
        var btn = button(x.uid, x.x, x.y, x.w, x.h, ModAPI.util.str(x.text));
        return btn;
    });
    if (actionBindMode !== 1) {
        ModAPI.hooks.methods[ModAPI.util.getMethodFromPackage(actionBindMode === 2 ? "net.minecraft.client.gui.GuiScreen" : bindingClass, "actionPerformed")] = function (...args) {
            var id = ModAPI.util.wrap(args[1]).getCorrective().id;
            var jsAction = inputArr.find(x => x.uid === id);
            if (jsAction) {
                jsAction.click(ModAPI.util.wrap(args[0]));
            }
            return originalActionPerformed.apply(this, args);
        }
    }
    ModAPI.hooks.methods[ModAPI.util.getMethodFromPackage(bindingClass, "initGui")] = function (...args) {
        originalInit.apply(this, args);
        var gui = ModAPI.util.wrap(args[0]).getCorrective();
        out.forEach(guiButton => {
            gui.buttonList.add(guiButton);
        });
    }
}


(() => {
    ModAPI.require("player");
    var backlog = [];
    var delayState = false;

    const originalSend = WebSocket.prototype.send;

    // Override WebSocket.send, so when eagler tries to send messages, it runs our code instead
    Object.defineProperty(WebSocket.prototype, 'send', {
        configurable: true,
        enumerable: false,
        writable: false,
        value: function (data) {
            // If blinking, push data to backlog along with its websocket instance.
            if (delayState) {
                backlog.push({ data: data, thisArg: this });
            } else { // Else send the data as normal
                originalSend.call(this, data);
            }
        }
    });

    ModAPI.meta.title("Dupe Hunting");
    ModAPI.meta.description("⚠️Only works over WS, not local. May induce bans.⚠️");
    ModAPI.meta.credits("by ZXMushroom63");

    var dupeHuntButtons = [{
        text: "Silently Close",
        click: () => {
            ModAPI.minecraft.displayGuiScreen(null);
        },
        x: 0,
        y: 0,
        w: 100,
        h: 20,
        uid: 142715254
    },
    {
        text: "Toggle Delay",
        click: () => {
            delayState = !delayState;
            alert(delayState ? "Delay On" : "Sending Packets...");
            if (delayState === false) {
                for (let i = 0; i < backlog.length; i++) {
                    const backlogItem = backlog[i];
                    originalSend.call(backlogItem.thisArg, backlogItem.data);
                }
                backlog = [];
            }
        },
        x: 0,
        y: 20,
        w: 100,
        h: 20,
        uid: 142715253
    },
    {
        text: "Server Close",
        click: () => {
            var CloseWindow = ModAPI.reflect.getClassByName("C0DPacketCloseWindow").constructors[0];
            ModAPI.player.sendQueue.addToSendQueue(CloseWindow(ModAPI.player.openContainer.getCorrective().windowId));
        },
        x: 0,
        y: 40,
        w: 100,
        h: 20,
        uid: 142715252
    },
    {
        text: "Send & Disconnect",
        click: () => {
            delayState = false;
            for (let i = 0; i < backlog.length; i++) {
                const backlogItem = backlog[i];
                originalSend.call(backlogItem.thisArg, backlogItem.data);
            }
            backlog = [];
            ModAPI.mc.getNetHandler().getNetworkManager().doClientDisconnect(ModAPI.hooks._classMap[ModAPI.util.getCompiledName("net.minecraft.util.ChatComponentText")].constructors[0](ModAPI.util.str("Dupe Hunting Utils Disconnect")));
        },
        x: 0,
        y: 60,
        w: 100,
        h: 20,
        uid: 142715251
    }
    /* Removed "Use Chat" button here */
    ];

    [
        "net.minecraft.client.gui.inventory.GuiInventory",
        "net.minecraft.client.gui.inventory.GuiContainerCreative",
        "net.minecraft.client.gui.inventory.GuiBeacon"
    ].forEach(ui => {
        button_utility_script(dupeHuntButtons, ui, 0);
    });

    // Add global key listener for 'P' to open chat prompt and send chat when NO GUI is open (keeps original behavior)
    window.addEventListener("keydown", function(event) {
        if (event.key && event.key.toLowerCase() === "p" && !ModAPI.mc.currentScreen) { // only if no GUI open
            event.preventDefault();
            var p = window.prompt("Input chat/command:", "Hello World");
            if (p) {
                ModAPI.player.sendChatMessage(ModAPI.util.str(p));
            }
        }
    });

    // --- NEW: Hook GuiScreen.keyTyped so 'P' also works while GUIs are open ---
    try {
        var keyTypedMethodRef = ModAPI.util.getMethodFromPackage("net.minecraft.client.gui.GuiScreen", "keyTyped");
        var originalKeyTyped = ModAPI.hooks.methods[keyTypedMethodRef];

        // Replace the keyTyped hook
        ModAPI.hooks.methods[keyTypedMethodRef] = function (...args) {
            // args convention: (typedChar, keyCode) as parameters to the method when invoked on a GuiScreen instance.
            // 'this' is the GuiScreen instance.
            try {
                var typedChar = args[0];
                // derive a string representation
                var charStr = typeof typedChar === "string" ? typedChar : String.fromCharCode(typedChar || 0);

                // Detect if any text field or other component is focused to avoid interfering with typing.
                var guiThis = this;
                var focusDetected = false;
                try {
                    // Heuristic: search properties on the GUI instance for objects that expose isFocused() or getFocused()
                    for (var prop in guiThis) {
                        if (!guiThis.hasOwnProperty(prop)) continue;
                        try {
                            var candidate = guiThis[prop];
                            if (!candidate) continue;
                            // check for isFocused function (GuiTextField)
                            if (typeof candidate.isFocused === "function") {
                                if (candidate.isFocused()) {
                                    focusDetected = true;
                                    break;
                                }
                            }
                            // some implementations have getFocused or isFocused property
                            if (typeof candidate.getIsFocused === "function") {
                                if (candidate.getIsFocused()) {
                                    focusDetected = true;
                                    break;
                                }
                            }
                        } catch (e) {
                            // ignore property access errors
                        }
                    }
                } catch (e) {
                    // ignore focus detection errors
                }

                // If not focused and pressed 'p', open prompt and send chat.
                if (!focusDetected && charStr && charStr.toLowerCase() === "p") {
                    try {
                        // prevent default GUI behavior for this char
                        // open prompt
                        var p = window.prompt("Input chat/command:", "Hello World");
                        if (p) {
                            ModAPI.player.sendChatMessage(ModAPI.util.str(p));
                        }
                        // return without calling original to avoid double-handling
                        return null;
                    } catch (e) {
                        // if prompt fails, fall through to original behavior
                    }
                }
            } catch (e) {
                // ignore any hook logic errors and fall back to original
            }

            // default: call original keyTyped method
            return originalKeyTyped.apply(this, args);
        };
    } catch (e) {
        // If hooking fails for any reason, fallback: do nothing (global listener still works when no GUI open)
        // console.log("Failed to hook GuiScreen.keyTyped:", e);
    }

})();
